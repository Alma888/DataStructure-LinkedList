
链表（重点）
   1、链表的概念
          概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元
                    素的逻辑顺序是通过链表中的引用链接次序实现的 。
                  （逻辑上有前后关系，但在物理上不保证前后关系）
     2、链表的相关操作
  【插入】
 （1）链表的头插
        1.如果要插入的数据没有结点，先给它装入一个结点中
           Node node = new Node();
           node .value = 0;
        2.让原来的第一个结点成为新结点的下一个结点
           node.next = head;
        3.更新最新的第一个结点为新结点
           head = node;
（2）打印链表
            Node cur=head;
             while(cur!=null){
                  System.out.println(cur.val);
                 cur=cur.next;
            }

    （3）链表的尾插
      1.如果要插入的数据没有结点，先给它装入一个结点中
               让新结点的next=null
               Node node=new Node（val）;
            2.找到倒数第一个结点（子问题）
               Node last = head;
               while (last.next!=null)  {last = last.next;}
               last 就是最后一个结点
      3.让原来的倒数第一个结点的下一个为新结点
               last.next = node;
      4.尾插需要分情况讨论:
          （1）空链表的情况 ：就是让新的结点成为第一个结点
          （2）非空链表的情况
                   按下面处理：
                   构造方法中已经让.next=null了
                   找到.next==null的结点

  【删除】
 （1）链表的头删
                分情况讨论：
              1. 空链表，没有结点，则报错，，无法删除。
              2. 只有一个结点-------------直接删除头结点
              3. 大于一个结点
                   让头结点指向链表的第二个结点。第一个结点没有引用指向，自动
                被系统视为垃圾处理了
      （2）链表的尾删
  1. 找到倒数第二个结点
            lastSecond . next . next==null就是倒数第二个结点
             2. 让倒数第二个结点的next = null
       3. 原来最后一个结点因为没有引用指向而被回收


3、 ——————链表相交带环问题——————
    1. 链表相交的判断问题：
           思路1：
     （1）先各自求出链表的长度
     （2）让长的先走长度差步
     （3）同时走，第一次相遇时就是交点
           思路2：
     （1）我们使用两个指针 p1，p2 分别指向两个链表 headA，
             headB 的  头结点，然后同时分别逐结点遍历，
     （2）当 p1 到达链表 headA 的末尾时,重新定位到链表 headB 的
              头结点；
                               当 p2 到达链表 headB 的末尾时，重新定位到链表 headA
                               的头结点。
                      （3） 这样当它们相遇时，所指向的结点就是第一个公共结点。

    2. 链表的带环问题
     （1）快慢指针（一个1步，一个2步，不能一个1步，一个n步，
              n>2，  可能会错过）
     （2）如果相遇，带环，如果快的遇到null则不带环
     （3）求入环点
              A、转换为相交问题
              B、一个从起点出发，一个从相遇点出发，都走1步，一定
                   相遇在入环点（需要证明）

   3. 相交+带环问题（了解，6种情况）
**复杂链表复制
    （1）简单复制无法解决（因为是浅拷贝）
    （2）需要先复制结点，后解决random问题
    （3）如果能从老的结点找到新的结点，问题好解决
结构：
     1. 老结点—新结点—老结点—新结点
     2. 处理random指向
     3. 拆开新旧链表，返回新链表

4、顺序表和链表的区别和联系
       顺序表：  空间连续、支持O(1)随机访问(下标访问)
                      1.中间或前面部分的插入删除时间复杂度O(N)
                      2.增容的代价比较大。
                      3.不容易有内存碎片
                      4.对缓存更友好（了解）
                      5.单个数据而言，空间更节省
       链表：以节点为单位存储，不支持随机访问所有：
                      1.头插/尾插/头删/尾删：时间复杂度为O(1)
                      2.如果数据比较大了，不需要预留空间，没有增容问题，插入一
                          个开辟一个空间。
   （没有特殊理由，一律用顺序表就可以了）



